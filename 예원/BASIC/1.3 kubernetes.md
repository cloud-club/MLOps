# 컨테이너 개발 시대

## 🐳 기존의 가상화 기술 vs 도커

기존 VM 기술은 단일 물리서버 위에 가상 OS들을 실행해 커플리케이션 격리 - 논리적으로 구분된 공간에서 독립되어 있어 가상환경끼리 서로 영향을 주지 않음

<img width="630" alt="스크린샷 2023-03-16 오후 2 31 39" src="https://user-images.githubusercontent.com/77239220/225523866-95e192bd-dc30-4903-9348-1e69be233ad4.png">

그러나.. 호스트 OS 위에 또 다른 OS를 실행하기 때문에 실행 비용에 대한 부담이 큼. 
-> 컨테이너 기술은 실행 비용을 cgroup, namespace 등의 커널 기능으로 해결 (운영체제는 공유하되 리소스만 격리)

정리해보면 도커와의 차이점은 게스트OS의 유무! VM는 하나씩 늘어날 때마다 OS를 위한 자원을 할당해주어야 하는 반면에 도커는 어플리케이션을 구동하는데 필요한 모든 패키지만 있으면 컨테이너를 구동시킬 수 있다.


# ⚓ 쿠버네티스
개념 정리 ing..

## 아키텍처
쿠버네티스는 크게 마스터(Master)와 노드(Node) 두 개의 컴포넌트로 분리됨

- 마스터: 쿠버네티스의 설정 환경 저장, 전체 클러스터 관리
- 노드: 파드나 컨테이너 처럼 쿠버네티스 위에서 동작하는 워크로드를 호스팅


<details>
<summary>마스터 구성</summary>
<div markdown="1">

1. API 서버
쿠버네티스는 모든 명령과 통신을 API를 통해서 함. API 서버는 쿠버네티스의 모든 기능들을 REST API로 제공하고 그에 대한 명령을 처리

2. Etcd
DB 역할을 하는 서버.
etcd라는 분산형 키/밸류 스토어 오픈소스로 k8s 클러스터의 의 설정정보나 클러스터의 상태를 저장함.

3. 스케쥴러
파드,서비스 등 각 리소스들을 적절한 노드에 할당하는 역할을 함

4. 컨트롤러 매니져
컨트롤러를 생성하고 이를 각 노드에 배포/관리

    컨트롤러? : 파드를 관리하는 역할을 함. 
    - 레플리카셋 (지정된 수의 파드가 항상 실행되도록 유지) 
    - 디플로이먼트 (가장 기본, stateless 어플리케이션 배포 시 사용)
    참고로 디플로이먼트를 생성하면 replica 수대로 파드 생성되고 이를 관리할 레플리카셋도 생성됨
    - 데몬셋 (데몬 프로세스로 띄워야 할 앱이 있을 때 사용, 단 하나의 파드 실행하기 때문에 노드가 죽으면 사라짐. 예시: 로그 수집기, 모니터링 프로세스)
    - 스테이트풀셋 (상태를 갖고 있는 파드를 관리)
    - 잡 (파드가 요청된 작업을 실행 후 정상적으로 종료되었는지 관리. 한번만 실행하는 작업들에 적합함! 예시: 도커이미지, 머신러닝 학습)
    등이 있음 

5. DNS
쿠버네티스는 리소스의 엔드포인트(Endpoint)를 DNS로 맵핑하고 관리함. Pod, 서비스 등은 ip를 배정받는데, 이 ip는 동적으로 생성되기 때문에 변경이 됨 -> 쿠버네티스에서는 이를 내부 DNS서버를 두는 방식으로 해결! 새로운 리소스가 생기면, 그 리소스의 ip와 DNS 이름을 등록.

</div>
</details>

<details>
<summary>노드</summary>
<div markdown="1">

1. Kubelet
노드에 배포되는 에이전트 - 마스터 *API서버*와 통신해서 노드가 수행해야 할 명령을 받아 수행하고, 반대로 노드의 상태 등을 마스터로 전달

2. Kube-proxy
네트워크 트래픽을 적절한 컨테이너로 라우팅 및 로드밸런싱. 노드로 들어오는/나가는 네트워크 트래픽과, 마스터와의 네트워크 통신을 관리. 

3. Container runtime
파드를 통해서 배포된 컨테이너를 실행. 도커같은..

4. cAdvisor
각 노드에서 동작하는 모니터링 에이전트. 노드 내 컨테이너들의 상태와 성능 등의 정보를 수집하여 마스터 서버의 API 서버로 전달!

</div>
</details>

